// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INPUTDATA_H_
#define FLATBUFFERS_GENERATED_INPUTDATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

struct GPInputMoveData;
struct GPInputMoveDataBuilder;

struct InputAction_ChoseCard;
struct InputAction_ChoseCardBuilder;

struct GPInputPlayerData;
struct GPInputPlayerDataBuilder;

struct GPInputData;
struct GPInputDataBuilder;

enum GPInputStateData : uint8_t {
  GPInputStateData_NONE = 0,
  GPInputStateData_GPInputMoveData = 1,
  GPInputStateData_MIN = GPInputStateData_NONE,
  GPInputStateData_MAX = GPInputStateData_GPInputMoveData
};

inline const GPInputStateData (&EnumValuesGPInputStateData())[2] {
  static const GPInputStateData values[] = {
    GPInputStateData_NONE,
    GPInputStateData_GPInputMoveData
  };
  return values;
}

inline const char * const *EnumNamesGPInputStateData() {
  static const char * const names[3] = {
    "NONE",
    "GPInputMoveData",
    nullptr
  };
  return names;
}

inline const char *EnumNameGPInputStateData(GPInputStateData e) {
  if (::flatbuffers::IsOutRange(e, GPInputStateData_NONE, GPInputStateData_GPInputMoveData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGPInputStateData()[index];
}

template<typename T> struct GPInputStateDataTraits {
  static const GPInputStateData enum_value = GPInputStateData_NONE;
};

template<> struct GPInputStateDataTraits<GPInputMoveData> {
  static const GPInputStateData enum_value = GPInputStateData_GPInputMoveData;
};

bool VerifyGPInputStateData(::flatbuffers::Verifier &verifier, const void *obj, GPInputStateData type);
bool VerifyGPInputStateDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum GPInputActionData : uint8_t {
  GPInputActionData_NONE = 0,
  GPInputActionData_InputAction_ChoseCard = 1,
  GPInputActionData_MIN = GPInputActionData_NONE,
  GPInputActionData_MAX = GPInputActionData_InputAction_ChoseCard
};

inline const GPInputActionData (&EnumValuesGPInputActionData())[2] {
  static const GPInputActionData values[] = {
    GPInputActionData_NONE,
    GPInputActionData_InputAction_ChoseCard
  };
  return values;
}

inline const char * const *EnumNamesGPInputActionData() {
  static const char * const names[3] = {
    "NONE",
    "InputAction_ChoseCard",
    nullptr
  };
  return names;
}

inline const char *EnumNameGPInputActionData(GPInputActionData e) {
  if (::flatbuffers::IsOutRange(e, GPInputActionData_NONE, GPInputActionData_InputAction_ChoseCard)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGPInputActionData()[index];
}

template<typename T> struct GPInputActionDataTraits {
  static const GPInputActionData enum_value = GPInputActionData_NONE;
};

template<> struct GPInputActionDataTraits<InputAction_ChoseCard> {
  static const GPInputActionData enum_value = GPInputActionData_InputAction_ChoseCard;
};

bool VerifyGPInputActionData(::flatbuffers::Verifier &verifier, const void *obj, GPInputActionData type);
bool VerifyGPInputActionDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct GPInputMoveData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPInputMoveDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           verifier.EndTable();
  }
};

struct GPInputMoveDataBuilder {
  typedef GPInputMoveData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(GPInputMoveData::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(GPInputMoveData::VT_Y, y, 0.0f);
  }
  explicit GPInputMoveDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPInputMoveData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPInputMoveData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPInputMoveData> CreateGPInputMoveData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f) {
  GPInputMoveDataBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct InputAction_ChoseCard FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InputAction_ChoseCardBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CARD_ID = 4
  };
  uint32_t card_id() const {
    return GetField<uint32_t>(VT_CARD_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CARD_ID, 4) &&
           verifier.EndTable();
  }
};

struct InputAction_ChoseCardBuilder {
  typedef InputAction_ChoseCard Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_card_id(uint32_t card_id) {
    fbb_.AddElement<uint32_t>(InputAction_ChoseCard::VT_CARD_ID, card_id, 0);
  }
  explicit InputAction_ChoseCardBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InputAction_ChoseCard> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InputAction_ChoseCard>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InputAction_ChoseCard> CreateInputAction_ChoseCard(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t card_id = 0) {
  InputAction_ChoseCardBuilder builder_(_fbb);
  builder_.add_card_id(card_id);
  return builder_.Finish();
}

struct GPInputPlayerData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPInputPlayerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE_TYPE = 4,
    VT_STATE = 6,
    VT_ACTION_TYPE = 8,
    VT_ACTION = 10
  };
  GPInputStateData state_type() const {
    return static_cast<GPInputStateData>(GetField<uint8_t>(VT_STATE_TYPE, 0));
  }
  const void *state() const {
    return GetPointer<const void *>(VT_STATE);
  }
  template<typename T> const T *state_as() const;
  const GPInputMoveData *state_as_GPInputMoveData() const {
    return state_type() == GPInputStateData_GPInputMoveData ? static_cast<const GPInputMoveData *>(state()) : nullptr;
  }
  GPInputActionData action_type() const {
    return static_cast<GPInputActionData>(GetField<uint8_t>(VT_ACTION_TYPE, 0));
  }
  const void *action() const {
    return GetPointer<const void *>(VT_ACTION);
  }
  template<typename T> const T *action_as() const;
  const InputAction_ChoseCard *action_as_InputAction_ChoseCard() const {
    return action_type() == GPInputActionData_InputAction_ChoseCard ? static_cast<const InputAction_ChoseCard *>(action()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE_TYPE, 1) &&
           VerifyOffset(verifier, VT_STATE) &&
           VerifyGPInputStateData(verifier, state(), state_type()) &&
           VerifyField<uint8_t>(verifier, VT_ACTION_TYPE, 1) &&
           VerifyOffset(verifier, VT_ACTION) &&
           VerifyGPInputActionData(verifier, action(), action_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GPInputMoveData *GPInputPlayerData::state_as<GPInputMoveData>() const {
  return state_as_GPInputMoveData();
}

template<> inline const InputAction_ChoseCard *GPInputPlayerData::action_as<InputAction_ChoseCard>() const {
  return action_as_InputAction_ChoseCard();
}

struct GPInputPlayerDataBuilder {
  typedef GPInputPlayerData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state_type(GPInputStateData state_type) {
    fbb_.AddElement<uint8_t>(GPInputPlayerData::VT_STATE_TYPE, static_cast<uint8_t>(state_type), 0);
  }
  void add_state(::flatbuffers::Offset<void> state) {
    fbb_.AddOffset(GPInputPlayerData::VT_STATE, state);
  }
  void add_action_type(GPInputActionData action_type) {
    fbb_.AddElement<uint8_t>(GPInputPlayerData::VT_ACTION_TYPE, static_cast<uint8_t>(action_type), 0);
  }
  void add_action(::flatbuffers::Offset<void> action) {
    fbb_.AddOffset(GPInputPlayerData::VT_ACTION, action);
  }
  explicit GPInputPlayerDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPInputPlayerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPInputPlayerData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPInputPlayerData> CreateGPInputPlayerData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    GPInputStateData state_type = GPInputStateData_NONE,
    ::flatbuffers::Offset<void> state = 0,
    GPInputActionData action_type = GPInputActionData_NONE,
    ::flatbuffers::Offset<void> action = 0) {
  GPInputPlayerDataBuilder builder_(_fbb);
  builder_.add_action(action);
  builder_.add_state(state);
  builder_.add_action_type(action_type);
  builder_.add_state_type(state_type);
  return builder_.Finish();
}

struct GPInputData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPInputDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_INPUTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPInputPlayerData>> *player_inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPInputPlayerData>> *>(VT_PLAYER_INPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER_INPUTS) &&
           verifier.VerifyVector(player_inputs()) &&
           verifier.VerifyVectorOfTables(player_inputs()) &&
           verifier.EndTable();
  }
};

struct GPInputDataBuilder {
  typedef GPInputData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPInputPlayerData>>> player_inputs) {
    fbb_.AddOffset(GPInputData::VT_PLAYER_INPUTS, player_inputs);
  }
  explicit GPInputDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPInputData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPInputData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPInputData> CreateGPInputData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPInputPlayerData>>> player_inputs = 0) {
  GPInputDataBuilder builder_(_fbb);
  builder_.add_player_inputs(player_inputs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GPInputData> CreateGPInputDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<GPInputPlayerData>> *player_inputs = nullptr) {
  auto player_inputs__ = player_inputs ? _fbb.CreateVector<::flatbuffers::Offset<GPInputPlayerData>>(*player_inputs) : 0;
  return CreateGPInputData(
      _fbb,
      player_inputs__);
}

inline bool VerifyGPInputStateData(::flatbuffers::Verifier &verifier, const void *obj, GPInputStateData type) {
  switch (type) {
    case GPInputStateData_NONE: {
      return true;
    }
    case GPInputStateData_GPInputMoveData: {
      auto ptr = reinterpret_cast<const GPInputMoveData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGPInputStateDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGPInputStateData(
        verifier,  values->Get(i), types->GetEnum<GPInputStateData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGPInputActionData(::flatbuffers::Verifier &verifier, const void *obj, GPInputActionData type) {
  switch (type) {
    case GPInputActionData_NONE: {
      return true;
    }
    case GPInputActionData_InputAction_ChoseCard: {
      auto ptr = reinterpret_cast<const InputAction_ChoseCard *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGPInputActionDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGPInputActionData(
        verifier,  values->Get(i), types->GetEnum<GPInputActionData>(i))) {
      return false;
    }
  }
  return true;
}

inline const GPInputData *GetGPInputData(const void *buf) {
  return ::flatbuffers::GetRoot<GPInputData>(buf);
}

inline const GPInputData *GetSizePrefixedGPInputData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<GPInputData>(buf);
}

inline bool VerifyGPInputDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GPInputData>(nullptr);
}

inline bool VerifySizePrefixedGPInputDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GPInputData>(nullptr);
}

inline void FinishGPInputDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GPInputData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGPInputDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GPInputData> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_INPUTDATA_H_
